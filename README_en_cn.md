# Evergreen Skills for Software Developers
[![Codeship Status for romenrg/evergreen-skills-developers](https://app.codeship.com/projects/57d86950-fee3-0136-cc17-56b6e41314e7/status?branch=master)](https://app.codeship.com/projects/322711)

This repository includes a list of "evergreen skills" that should serve as a fair assessment of skilled software engineers / developers.

> 这个仓库包括了一份“常青技能”清单，这份清单应该可以作为对技术精湛的软件工程师/开发者客观评价。

The purpose of this work is to serve as an alternative resource for conducting technical interviews of software developers / engineers, when hiring. This document focuses on software development best practices, cross-framework principles and other portable skills; as opposed to the detrimental fixation on language trends and framework-specific knowledge that we often see in the industry.

> 这份工作的是为了在招聘软件开发者/工程师时，提供一个替代的技术面试的方案。文档关注的是软开发最佳实践、跨框架原则和通用的技能；而不是我们在行业中经常看到的语言层面，或者特定技术框架的内容。

Programming languages evolve constantly, companies change their tech stacks, frameworks quickly become outdated, and syntax-related questions can easily be looked up by skilled engineers in search engines in minutes, whenever they need it. So, does it make sense to focus on those aspects when interviewing candidates?

> 编程语言不断进化，公司也不断改变他们的技术栈，框架很快就会过时，有经验的工程师使用搜索引擎能在几分钟就能解决语法相关的问题。因此，在面试候选人时关注这些方面是否有意义呢？

On the other hand, there are software development best practices, cross-framework technical principles and critical non-technical skills that cannot be easily googled, take time to learn, are "evergreen" and have a huge impact on engineer's performance. These are significantly better at reflecting the real value a software developer / engineer brings to an organization or team.

> 另一方面，技术框架以外的原理和非技术的技能是在谷歌上查不到的，这些技能是“常青”的，并且对工程师的表现有巨大的影响。这些更能反映出软件开发者/工程师为团队带来的真正价值。

This repository is a derivative work of the following article: "[What Makes a Great Software Engineer](https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer)".

_This is a work in progress. Important knowledge might be missing, existing bullets can probably be improved and better grouping strategies could be found. For those reasons, any contributions (i.e. PRs or issues) are welcome._ Please feel free to propose changes following [the contributing guideline](CONTRIBUTING.md).

> 这个仓库是基于以下文章的一个衍生作品："[是什么造就了一位伟大的软件工程师](https://www.romenrg.com/blog/2018/12/29/what-makes-a-great-software-engineer)"。
>
> 这是一个正在进行中的工作。重要的知识可能缺失，现有的条目可能可以改进，更好的分组策略也可能被发现。因此，任何贡献（即PR或问题）都是受欢迎的。请随时按照[贡献指南](https://gptx.woa.com/CONTRIBUTING.md)提出修改建议。

## Table of contents

- [Non-technical skills](#non-technical-skills)
  - [Core skills](#core-skills-aka-soft-skills)
    - [Communication](#communication)
    - [Teamwork](#teamwork)
  - [Innovation & (self-)management skills](#innovation--self-management-skills)
    - [Development process](#development-process)
    - [Problem solving skills](#problem-solving-skills)
    - [Mindset](#mindset)
- [Technical skills](#technical-skills)
  - [General technical knowledge](#general-technical-knowledge)
    - [Programming principles](#programming-principles)
    - [Data structures](#data-structures) 
    - [Clean code](#clean-code)
    - [Source code management](#source-code-management)
    - [Technical collaboration](#technical-collaboration)
    - [DevOps practices](#devops-practices)
    - [Other general technical knowledge](#other-general-technical-knowledge)
      - [Language-theory knowledge](#language-theory-knowledge)
      - [Optimization](#optimization)
      - [Concurrency](#concurrency)   
  - [Field-specific technical knowledge](#field-specific-technical-knowledge)
    - [Front-end development](#front-end-development)
    - [Back-end development](#back-end-development)
    - [Architecture](#architecture)
    - [Infrastructure](#infrastructure)
    - [Security](#security)

## Non-technical skills

非技术技能

The following non-technical skills are probably the most critical for an engineer to have. Being successful as a software engineer in a company becomes very hard without good communication, teamwork attitude, development-process knowledge, problem-solving skills and a learning mindset; despite the technical skills one may have.

> 以下非技术能力可能是开发者最重要的能力。尽管一个人可能具备很强的技术能力，但在公司中没有良好的沟通、团队合作态度、开发流程、解决问题的能力和学习的心态的话，一切会变得非常糟糕。

### Core Skills (aka "soft" skills) 

核心技能（又称“软技能”）

#### Communication

* Follow e-mail best practices (e.g. [some e-mail etiquette rules](https://www.grammarly.com/blog/email-etiquette-rules-to-know/))

  遵循邮件使用的最佳策略(例： [some e-mail etiquette rules](https://www.grammarly.com/blog/email-etiquette-rules-to-know/))

* Follow chat best practices (e.g. [use threads to organize discussions](https://slack.com/intl/en-es/help/articles/115000769927-Use-threads-to-organize-discussions-) and [other best-practices from Slack](https://blog.rescuetime.com/slack-focus-guide/))

  遵循沟通的最佳策略

  两份链接指向的 slack 的一则使用文档和一份 slack 使用技巧文档

* [Minimize interruptions](https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html)

  [最小化干扰](https://jaxenter.com/aaaand-gone-true-cost-interruptions-128741.html)

  链接指向的文章是一篇关于程序员在工作中，因被其他事项而中断程序开发的影响，一般人，在工作过程中断打扰后大约需要23分钟才能恢复到之前的状态，而程序员需要更久，文中强调了工作中断对程序员工作效率和心情的影响，并讨论了有计划和非计划性中断的不同影响。

* Be polite

  保持礼貌

#### Teamwork

团队

* [Practice empathy](https://simpleprogrammer.com/empathy-software-developers)

  练习同理心

* Keep low egos

  保持谦逊和低调

* Be an active listener

  做一个积极倾听的人

* Be a good mentor

  做一个好的导师

* Share knowledge

  知识分享

* Be constructive

  得有见地

### Innovation & (self-)management skills

创新和自我管理技能

#### Development process

* Know about [Agile Software Development principles](https://agilemanifesto.org/principles.html)

  了解[《敏捷开发原则》](https://agilemanifesto.org/principles.html)

* Be comfortable with iterative and incremental development

  适应迭代和增量开发

* Have self-organizing capabilities

  自组织的能力

  指的是个体或系统能够自发地、无需外部强制指挥，根据内部规则和相互作用来组织自身结构和行为的能力。这种能力在多个层面都有体现，包括个人自我管理、团队协作以及更广泛的社会和生态系统

* Avoid creating false expectations (e.g. with [time estimates](https://www.romenrg.com/blog/2015/09/28/why-asking-developers-for-time-estimates-in-software-projects-is-a-terrible-idea-and-how-to-bypass-it-with-scrum/))

  避免产生错误的预估（比如：工时预估）

* Focus on priorities and business value

  关注优先级和业务价值

#### Problem solving skills

* Applying the [Scientific Method](https://en.wikipedia.org/wiki/Scientific_method)

  使用科学方法

  > 科学方法是一种有系统地寻求知识的程序，涉及了以下三个步骤：问题的认知与表述、实验数据的收集、假说的构成与测试。

* Researching skills

  检索能力

* [Lateral Thinking](https://www.edwddebono.com/lateral-thinking)

  横向思维

  > 横向思维，指使用间接的、具有创造力的、不是一望而知的推理方式来解决问题

* Abstraction

  抽象化能力

* Creativity

  创造力

* [5 Whys](http://en.wikipedia.org/wiki/5_Whys)

  五问法

  > 五问法关键所在就是，鼓励解决问题的人要努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，穿越不同的抽象层面，直至找出原有问题的根本原因。简而言之，就是鼓励解决问题的人要有“打破砂锅问到底”的精神。

* Risk management

  风险管理

#### Mindset

心态

* Don't fear change

  不要害怕变化

* Dare to fail

  敢于失败

* Be a life-long learner

  终生学习

* [Critical Thinking](https://en.wikipedia.org/wiki/Critical_thinking) (be rational, question decisions, "let the facts do the talking")

  批判性思维（保持理性，质疑决定，“让事实说话”）

  

## Technical skills

### General technical knowledge

There is evergreen technical knowledge that is relevant for any software engineer, despite the specific area in which they are going to be working on. To get a good understanding of their seniority and learn how solid their engineering practices are, you can keep a conversation with them on programming principles, data structures, clean code, source code management, technical collaboration and/or DevOps practices. If these foundations are solid, they will probably be able to learn the specifics needed for your particular case without problems. 

> 有一些技术知识是永恒的，对任何软件工程师都有关，尽管他们将要从事的具体领域各不相同。为了深入了解他们的资历并了解他们的工程实践有多扎实，你可以和他们就编程原理、数据结构、清晰的代码、源代码管理、技术协作或者DevOps实践等主题进行交谈。如果这些基础扎实，他们可能能够毫无问题地学习你们特定领域的东西。

#### Programming principles

编程准则

 * Basic [control structures](https://en.wikipedia.org/wiki/Control_flow) and [boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra)
   基本流程结构和逻辑代数

 * OOP (Object Oriented Programming)

   面向对象编程

 * [SOLID](https://en.wikipedia.org/wiki/SOLID), [GRASP](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))

   面向对象设计

   > **SOLID**（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）
   >
   > |      |                                                            |                                                              |
   > | :--: | ---------------------------------------------------------- | ------------------------------------------------------------ |
   > |  S   | [单一功能原则](https://zh.wikipedia.org/wiki/单一功能原则) | 认为“对象应该仅具有一种单一功能”的概念。                     |
   > |  O   | [开闭原则](https://zh.wikipedia.org/wiki/开闭原则)         | 认为“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。   |
   > |  L   | [里氏替换原则](https://zh.wikipedia.org/wiki/里氏替换原则) | 认为“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。参考契约式设计。 |
   > |  I   | [接口隔离原则](https://zh.wikipedia.org/wiki/接口隔离原则) | 认为“多个特定客户端接口要好于一个宽泛用途的接口”的概念。     |
   > |  D   | [依赖反转原则](https://zh.wikipedia.org/wiki/依赖反转原则) | 认为一个方法应该遵从“依赖于抽象而不是一个实例”的概念。 依赖注入是该原则的一种实现方式。 |
   >
   > **GRASP**中提到的模式和原则包括有控制器（controller）、创建者（creator）、中介（indirection）、信息专家（information expert）、低耦合性（low coupling）、高内聚性（high cohesion）、多态（polymorphism）、保护变化（protected variations）和纯虚构（pure Fabrication）[2]

   

 * Functional programming (pure functions, immutability, recursion,...)

   函数式编程（纯函数、不变性、递归……）

 * [Declarative vs Imperative programming](http://amzotti.github.io/programming%20paradigms/2015/02/13/what-is-the-difference-between-procedural-function-imperative-and-declarative-programming-paradigms/)

   声明式与命令式编程

   > 声明式和命令式编程范例只不过是描述在不同抽象层次上编码的流行词。声明式编程关注的是“做什么，而不是如何做”，而命令式编程则关注的是“如何做，而不是做什么”。声明式编程是在比命令式编程更高的抽象层次上进行编程。两者都有其适用的地方，例如在网页开发中使用框架时需要声明式编程，而在设计算法和其他底层需求时则需要命令式编程。

#### Data structures

数据结构

 * Basic structures (basic types, array, matrix, object...)

   级别数据结构（基本类型、数组、矩阵、对象...）

 * Caching / memoization

   缓存和memoization

   memoization 没有一个很好的词能翻译，大概意思就是通过存储函数调用的结果，并在再次使用相同输入调用函数时直接返回已存储的结果，从而加速计算逻辑。斐波那契数列就是一个使用 memoization 的例子

 * Hash codes, tokens, encodings (e.g. Base64)

   Hash codes、 tokens、编码（比如 Base64）

 * [Stack vs heap](https://stackoverflow.com/a/80113/1213497) memory

   栈与堆内存

   链接指向一则在 stackoverflow 提出：堆栈相关的诸多疑问，最高数回答解释了堆栈两种内存分配方式的基本概念、操作方式和性能差异，其中栈内存分配方式由于其后进先出的特性和近距离的存取模式，使得其在内存分配和回收上更加高效；而堆内存分配方式由于其动态和灵活的特性，对内存的管理相对复杂，但能够满足更多的内存需求

#### Clean code

代码整洁

 * Acknowledge that naming is key to code readability (files, classes, variables / attributes, functions / methods...)

     懂得命名对代码的可读性的重要性

 * Avoid long functions and classes, making sure to split responsibilities properly into methods/functions and/or classes/files

     避免过长的方法和类，确保职责被划分到各个方法或者类中

 * Follow conventions to organize project structure

     遵循约定来管理项目结构

 * Extract complex boolean conditions into well-named functions

     将复杂的布尔条件提取到命名良好的函数中

 * Try to write code that is as self-explanatory as possible (i.e. "what" the code does is easy to understand by reading it)

     尽量编写尽可能自解释的代码（即通过阅读代码就能容易理解代码的功能）

 * Favor good naming and lightweight documentation over inline comments
   
     良好的命名和轻量的文档而不是行内注释
     
     [Code comments often lie](https://www.codeproject.com/Articles/872073/Code-Comments-are-Lies) and are usually shortcuts written to explain what a messy code block does, instead of investing the time in refactoring it to improve its readability
     
     代码注释通常可能会误导人，因为它们经常被用作一种捷径，用来解释一段混乱的代码块的功能，而不是投入时间去重构它以提高其可读性。
     
     链接的文章主张编写清晰、自解释和可维护的代码，而不是过度依赖注释，同时也承认在某些特殊情况下，注释是有其必要性和价值的。
     
 * Write documentation as code, ideally alongside code, for easier maintenance (e.g. markdown files in a "docs" folder in your repository)

     将文档编写为代码，理想情况下与代码一起，以便于维护（例如，在仓库中的“docs”文件夹中的 markdown 文件）

 * Use docs to describe "whys" and "hows" (e.g. goals, use cases, components, high-level architecture overview,...)

     使用文档来描述“为什么”和“怎么做”（例如，目标、用例、组件、高级架构概述等）

 * In OOP, favor [composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)

     在面向对象编程中，组合优于继承

 * Follow [semantic versioning](https://semver.org/)

     遵循语义化版本控制

 * Know about TDD and its practices (e.g. "red, green, refactor")

     了解TDD及其实践（例如，“红色，绿色，重构”）

     > **TDD**(测试驱动开发)是戴两顶帽子思考的开发方式：先戴上实现功能的帽子，在测试的辅助下，快速实现其功能；再戴上测试驱动开发的帽子，在测试的保护下，通过去除冗余的代码，提高代码品质。测试驱动着整个开发过程：首先，驱动代码的设计和功能的实现；其后，驱动代码的再设计和重构。
     >
     > - 红色：首先编写一个针对新功能的测试用例，此时由于功能尚未实现，测试用例将无法通过（失败，显示红色）
     >
     > - 绿色：接下来编写功能代码，使得测试用例能够通过（成功，显示绿色）。在这个阶段，重点是让测试通过，而不是编写完美的代码。
     >
     > - 重构：在测试用例通过后，对功能代码进行优化和重构，提高代码质量，同时确保测试用例仍然能够通过。

#### Source code management

源码管理能力

 * CVS (Control Version Systems) / SCM (Source Code Management) basics: branches, tags, centralized vs de-centralized,...

   CVS（控制版本系统）/ SCM（源代码管理）基础知识：分支、标签、集中式与分散式等

 * SCM vs repository management / hosting (i. e. [difference between Git and GitHub](https://stackoverflow.com/a/13321586))

   SCM与仓库管理/托管的区别（即[Git与GitHub之间的区别](https://stackoverflow.com/a/13321586)）

 * Understand why versioning is important

   理解版本化的重要性

 * Commit best practices
   * [Micro commits](https://lucasr.org/2011/01/29/micro-commits/) / atomic commits, good descriptions...)
   
     微提交/原子提交，良好的描述等
   
   * [Conventional commits](https://www.conventionalcommits.org/en/v1.0.0/)
   
     常规提交
   
 * Feature branches (short-lived)

   功能分支（短期）

 * Trunk-based development

   基于主干的开发

 * Dependency management (the importance of package managers, the risks of [dependency hell](https://en.wikipedia.org/wiki/Dependency_hell),...)

   依赖管理（包管理器的重要性，依赖地狱的风险等）

#### Technical collaboration

技术合作

* [Peer Code Review best practices](https://blog.github.com/2015-01-21-how-to-write-the-perfect-pull-request/)
  
    * TL;DR: Focus on the relevant pieces when performing code-reviews. The purpose is learning, not blaming.
    
      一句话来说就是：在执行代码审查时关注相关部分。目的是学习，而不是指责。
    
* [Pair Programming best practices](https://martinfowler.com/articles/on-pair-programming.html)

    结对编程最好的实践

    这篇文章主要讨论了结对编程（Pair Programming）的相关主题，包括其风格、时间管理、轮换策略、日常规划、物理环境设置、远程配对等方面。还探讨了结对编程的好处和挑战，以及如何说服管理者和同事采用这种方法。此外，文章还涉及了一些与配对编程相关的细节和常见问题

#### DevOps practices

DevOps 实践

 * Build automation

   自动化构建

 * Artifact repositories and image registries

   构件仓库和镜像注册表

 * Write automated tests

   编写自动化测试

 * Differences between unit, integration and end-to-end (e2e) tests

   单元、集成和端到端（e2e）测试之间的区别

 * Test pyramid

   测试金字塔

 * Continuous Integration

   持续集成

 * [Continuous Delivery vs Deployment](https://www.romenrg.com/blog/2017/12/31/continuous-integration-delivery-deployment/)

   持续交付与持续部署

 * Feature Flags / Feature Toggles

   功能 Flag 和功能开关

#### Other general technical knowledge

通用技术知识

##### Language-theory knowledge

语言理论知识

 * Regular expressions (regex)

   正则表达式（regex）

 * Compiled vs interpreted languages

   编译型与解释型语言

 * [Dynamic vs static & weak vs strong](https://medium.com/@cpave3/understanding-types-static-vs-dynamic-strong-vs-weak-88a4e1f0ed5f) language typing

   动态与静态 & 弱类型与强类型语言类型

##### Optimization

优化

 * Lazy loading

   懒加载

 * [Profiling](https://en.wikipedia.org/wiki/Profiling_(computer_programming))

   性能分析

##### Concurrency

并发

 * Race condition

   竞态条件

 * Deadlock

   死锁

 * Mutual exclusion

   互斥

### Field-specific technical knowledge

特定领域技术知识

In some cases, you may want an engineer to know about certain fields or areas already, such as front-end, back-end, architecture, infrastructure or security. In those cases, there are also cross-framework concepts and principles that can be used to drive conversations on technical knowledge that is specific to each one of those fields.

> 在某些情况下，您可能希望工程师已经了解某些特定领域，例如前端、后端、架构、基础设施或安全方面。在这些情况下，还有一些跨框架的概念和原则，可用于推动针对每个领域的特定技术知识的内容。

#### Front-end development

前端开发

 * API communication (different architecture standards, how data is transmitted...)

   API通信（不同的架构标准，数据如何传输...）

 * DOM (definition, understanding, virtual DOM...)

   DOM（定义，理解，虚拟DOM...）

 * Browser events

   浏览器事件

 * Responsive design (purpose, advantages, progressive enhancement...)

   响应式设计（目的，优点，渐进增强...）

 * Client-side rendering (CSR) vs server-side rendering (SSR)

   客户端渲染（CSR）与服务器端渲染（SSR）

 * Pagination

   分页

 * State management (associated problems, stateless approach...)

   状态管理（相关问题，无状态方法...）

 * MVC and derivatives

   MVC 和相关的衍生品

 * WebSockets

   WebSockets 网络通信协议

#### Back-end development

 * API design (different architecture standards, how data is transmitted...)

   API设计（不同的架构标准，数据如何传输...）

 * [Message brokers](https://en.wikipedia.org/wiki/Message_broker)

   消息代理

 * Relational databases (how they work, basic concepts...)

   关系型数据库（它们是如何工作的，基本概念...）

 * Non-relational databases

   非关系型数据库

 * Database design

   数据库设计

 * ORM

   ORM（对象关系映射）

 * Batch processes / Cron jobs

   批处理进程 / 定时任务

 * Session handling

   会话处理

 * [Error Handling, Auditing and Logging](https://lti.umuc.edu/contentadaptor/topics/byid/db0a8c4f-f738-4674-9f60-b75323cdb07f)

   错误处理、审查、日志记录

#### Architecture

架构

 * API
   * Standards: REST / SOAP
   
     标准协议：REST / SOAP 
   
   * Security (e.g. blocking bots, controlling account take-over attacks, etc.)
   
     安全性（例如拦截机器人，控制账户接管攻击等）
   
   * Resiliency on 3rd-party service failures (e.g. Circuit Breakers)
   
     针对第三方服务故障的弹性橱窗（例如断路器）
   
 * Externalized Configuration

   外部可配置化

 * [Everything as code (i.e. Configuration as code, Infrastructure as code, Docs as code,...)](https://www.romenrg.com/blog/2019/12/31/everything-as-code/)

   万物皆代码（即配置即代码，基础设施即代码，文档即代码...）

 * Monolith vs Microservices

   单体应用与微服务

 * Domain-Driven Design (DDD)

   领域驱动设计（DDD）

 * Hexagonal Architecture

   六边形架构

 * Service Mesh

   服务 Mesh

 * Relevant internet protocols and their usage (i.e. HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP,...)

   相关的互联网协议及其用法（如 HTTP, HTTPS, TCP, UDP, LDAP, SSH, SMTP...）

 * [Data modeling](https://en.wikipedia.org/wiki/Data_modeling)

   数据建模

 #### Infrastructure

基础设施

 * Virtual machines vs Containers

   虚拟机与容器

 * Processes vs threads

   进程与线程

 * Controller-agent / Primary-replica pattern

   控制器-代理/主副本模式

 * Client-server pattern

   C/S模式

 * IAAS, PAAS, SASS

 * Web servers

   Web服务器

 * Reverse proxies

   反向代理

 * Load balancing

   负载均衡

 * Redundancy

   冗余

 * Latency

   延迟

 * Monitoring

   监控

 * [Observability](https://docs.honeycomb.io/learning-about-observability/intro-to-observability/)

   可监控性

#### Security

安全

  * Identity and Access Management (IAM)
    
    身份和访问管理（IAM）
    
    * Authentication (JWT, SSO)
    
      认证（JWT, SSO）
    
    * Authorization (RBAC, ABAC)
    
      授权（RBAC, ABAC）
    
 * Public-key cryptosystems (e.g. RSA)

   公钥密码系统（例如RSA）

 * Cryptographic protocols (TLS, SSL)

   加密协议（TLS, SSL）

 * Principle of least privilege

   最小权限原则

 * DoS / DDoS

 * SQL injection

   SQL 注入

 * Man-in-the-middle attack

   中间人攻击

 * XSS and CSRF

   XSS（跨站脚本攻击） 和 CSRF（跨站请求伪造）

---

_This work, by [Romén Rodríguez-Gil](https://www.romenrg.com/about/), is released under the terms specified in [this license file](LICENSE) (MIT License)._
